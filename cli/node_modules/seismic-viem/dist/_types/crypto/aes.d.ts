import { type Hex } from 'viem';
export declare class AesGcmCrypto {
    private readonly key;
    private readonly ALGORITHM;
    private readonly TAG_LENGTH;
    private readonly NONCE_LENGTH;
    private readonly U64_SIZE;
    constructor(key: Hex);
    /**
     * Creates a nonce from a u64 number, matching Rust's implementation
     * @param num - The number to convert (will be treated as u64)
     */
    private numberToNonce;
    /**
     * Validates and converts a hex nonce to buffer
     * @param nonce - The nonce in hex format
     */
    private validateAndConvertNonce;
    /**
     * Creates a nonce from a number in a way compatible with the Rust backend
     */
    createNonce(num: number | bigint): Hex;
    /**
     * Encrypts data using either a number-based nonce or hex nonce
     */
    encrypt(plaintext: Hex, nonce: number | bigint | Hex): Promise<Hex>;
    /**
     * Decrypts data using either a number-based nonce or hex nonce
     * NOTE: not tested or called in any real way
     */
    decrypt(ciphertext: Hex | undefined, nonce: number | bigint | Hex): Promise<Hex | undefined>;
}
type AesInputKeys = {
    privateKey: Hex;
    networkPublicKey: string;
};
export declare const sharedSecretPoint: ({ privateKey, networkPublicKey, }: AesInputKeys) => Uint8Array;
export declare const sharedKeyFromPoint: (sharedSecret: Uint8Array) => string;
export declare const generateSharedKey: (inputs: AesInputKeys) => string;
export declare const deriveAesKey: (sharedSecret: string) => Hex;
export declare const generateAesKey: (aesKeys: AesInputKeys) => Hex;
export {};
//# sourceMappingURL=aes.d.ts.map