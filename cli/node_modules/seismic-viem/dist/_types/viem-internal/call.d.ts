import type { AccountStateConflictErrorType, Address, CallParameters, Chain, Client, Hex, InvalidAddressErrorType, NumberToHexErrorType, RpcStateOverride, StateAssignmentConflictErrorType, StateOverride, TransactionRequest, Transport } from 'viem';
import { BaseError } from 'viem';
export declare function shouldPerformMulticall({ request, }: {
    request: TransactionRequest;
}): boolean;
type InvalidBytesLengthErrorType = InvalidBytesLengthError & {
    name: 'InvalidBytesLengthError';
};
declare class InvalidBytesLengthError extends BaseError {
    constructor({ size, targetSize, type, }: {
        size: number;
        targetSize: number;
        type: 'hex' | 'bytes';
    });
}
type SerializeStateOverrideParameters = StateOverride | undefined;
type SerializeStateMappingErrorType = InvalidBytesLengthErrorType;
type SerializeAccountStateOverrideErrorType = NumberToHexErrorType | StateAssignmentConflictErrorType | SerializeStateMappingErrorType;
export type SerializeStateOverrideErrorType = InvalidAddressErrorType | AccountStateConflictErrorType | SerializeAccountStateOverrideErrorType;
export declare function serializeStateOverride(parameters?: SerializeStateOverrideParameters): RpcStateOverride | undefined;
export type ScheduleMulticallParameters<chain extends Chain | undefined> = Pick<CallParameters<chain>, 'blockNumber' | 'blockTag'> & {
    data: Hex;
    multicallAddress?: Address | undefined;
    to: Address;
};
export declare function scheduleMulticall<chain extends Chain | undefined>(client: Client<Transport>, args: ScheduleMulticallParameters<chain>): Promise<{
    data: undefined;
} | {
    data: `0x${string}`;
}>;
export type ErrorType<name extends string = 'Error'> = Error & {
    name: name;
};
export declare function toDeploylessCallViaBytecodeData(parameters: {
    code: Hex;
    data: Hex;
}): `0x${string}`;
export declare function toDeploylessCallViaFactoryData(parameters: {
    data: Hex;
    factory: Address;
    factoryData: Hex;
    to: Address;
}): `0x${string}`;
export declare function getRevertErrorData(err: unknown): `0x${string}` | undefined;
type Resolved<returnType extends readonly unknown[] = any> = [
    result: returnType[number],
    results: returnType
];
type BatchResultsCompareFn<result = unknown> = (a: result, b: result) => number;
type CreateBatchSchedulerArguments<parameters = unknown, returnType extends readonly unknown[] = readonly unknown[]> = {
    fn: (args: parameters[]) => Promise<returnType>;
    id: number | string;
    shouldSplitBatch?: ((args: parameters[]) => boolean) | undefined;
    wait?: number | undefined;
    sort?: BatchResultsCompareFn<returnType[number]> | undefined;
};
type CreateBatchSchedulerReturnType<parameters = unknown, returnType extends readonly unknown[] = readonly unknown[]> = {
    flush: () => void;
    schedule: parameters extends undefined ? (args?: parameters | undefined) => Promise<Resolved<returnType>> : (args: parameters) => Promise<Resolved<returnType>>;
};
export declare function withResolvers<type>(): PromiseWithResolvers<type>;
export declare function createBatchScheduler<parameters, returnType extends readonly unknown[]>({ fn, id, shouldSplitBatch, wait, sort, }: CreateBatchSchedulerArguments<parameters, returnType>): CreateBatchSchedulerReturnType<parameters, returnType>;
export {};
//# sourceMappingURL=call.d.ts.map