import type { ExtractAbiFunctionNames } from 'abitype';
import type { Abi, Account, Address, Chain, Client, ContractFunctionName, GetContractParameters, GetContractReturnType, IsNarrowable, IsNever, Transport } from 'viem';
import type { ShieldedWalletClient } from '../client';
import type { KeyedClient } from '../viem-internal/client';
import type { GetReadFunction, GetWriteFunction } from '../viem-internal/function';
type TransparentReadContractReturnType<TAbi extends Abi | readonly unknown[], TClient extends Client | KeyedClient = Client | KeyedClient, _readFunctionNames extends string = TAbi extends Abi ? Abi extends TAbi ? string : ExtractAbiFunctionNames<TAbi, 'pure' | 'view'> : string, _narrowable extends boolean = IsNarrowable<TAbi, Abi>, _walletClient extends Client | unknown = TClient extends {
    wallet: Client;
} ? TClient['wallet'] : TClient> = _walletClient extends Client ? IsNever<_readFunctionNames> extends true ? unknown : {
    tread: {
        [functionName in _readFunctionNames]: GetReadFunction<_narrowable, TAbi, functionName extends ContractFunctionName<TAbi, 'pure' | 'view'> ? functionName : never>;
    };
} : unknown;
type TransparentWriteContractReturnType<TAbi extends Abi | readonly unknown[], TClient extends Client | KeyedClient = Client | KeyedClient, _writeFunctionNames extends string = TAbi extends Abi ? Abi extends TAbi ? string : ExtractAbiFunctionNames<TAbi, 'nonpayable' | 'payable'> : string, _narrowable extends boolean = IsNarrowable<TAbi, Abi>, _walletClient extends Client | unknown = TClient extends {
    wallet: Client;
} ? TClient['wallet'] : TClient> = _walletClient extends Client ? IsNever<_writeFunctionNames> extends true ? unknown : {
    twrite: {
        [functionName in _writeFunctionNames]: GetWriteFunction<_narrowable, _walletClient['chain'], _walletClient['account'], TAbi, functionName extends ContractFunctionName<TAbi, 'nonpayable' | 'payable'> ? functionName : never>;
    };
} : unknown;
/**
 * The same as viem's {@link https://viem.sh/docs/contract/getContract.html#with-wallet-client GetContractReturnType}, with a few differences:
 * - `read` and `write` use signed reads & seismic transactions
 * - `tread` and `twrite` behave like viem's standard read & write
 */
export type ShieldedContract<TTransport extends Transport = Transport, TAddress extends Address = Address, TAbi extends Abi | readonly unknown[] = Abi, TChain extends Chain | undefined = Chain | undefined, TAccount extends Account = Account, TClient extends ShieldedWalletClient<TTransport, TChain, TAccount> | KeyedClient<TTransport, TChain, TAccount> = ShieldedWalletClient<TTransport, TChain, TAccount>> = GetContractReturnType<TAbi, TClient, TAddress> & TransparentReadContractReturnType<TAbi, TClient> & TransparentWriteContractReturnType<TAbi, TClient, TAddress>;
/**
 * This function extends viem's base {@link https://viem.sh/docs/contract/getContract.html getContract} functionality by adding:
 * - `write`: write to a contract with encrypted calldata
 * - `read`: read from a contract using a signed read
 * - `tread`: transparently read from a contract using an unsigned read (from the zero address)
 * - `twrite`: transparently write to a contract using non-encrypted calldata
 *
 * @param {GetContractParameters} params - The configuration object.
 *   - `abi` ({@link Abi}) - The contract's ABI.
 *   - `address` ({@link Address}) - The contract's address.
 *   - `client` ({@link ShieldedWalletClient}) - The client instance to use for interacting with the contract.
 *
 * @throws {Error} If the wallet client is not provided for shielded write or signed read operations.
 * @throws {Error} If the wallet client does not have an account configured for signed reads.
 *
 * @example
 * ```typescript
 * const contract = getShieldedContract({
 *   abi: myContractAbi,
 *   address: '0x1234...',
 *   client: shieldedWalletClient,
 * });
 *
 * // Perform a shielded write
 * await contract.write.myFunction([arg1, arg2], { gas: 50000n });
 *
 * // Perform a signed read
 * const value = await contract.read.getValue();
 * console.log('Value:', value);
 * ```
 *
 * @remarks
 * - The `read` property will always call a signed read
 * - The `tread` property will toggle between public reads and signed reads, depending on whether an `account` is provided
 * - The `write` property will encrypt calldata of the transaction
 * - The `twrite` property will make a normal write, e.g. with transparent calldata
 * - The client must be a {@link ShieldedWalletClient}
 */
export declare function getShieldedContract<TTransport extends Transport, TAddress extends Address, const TAbi extends Abi | readonly unknown[], const TClient extends ShieldedWalletClient<TTransport, TChain, TAccount> | KeyedClient<TTransport, TChain, TAccount>, TChain extends Chain | undefined = Chain | undefined, TAccount extends Account = Account>({ abi, address, client, }: GetContractParameters<TTransport, TChain, TAccount, TAbi, TClient, TAddress>): ShieldedContract<TTransport, TAddress, TAbi, TChain, TAccount, TClient>;
export {};
//# sourceMappingURL=contract.d.ts.map